#!/bin/bash
# PAIRED Bridge Monitor - Real-time Agent Message Display
# Shows live bridge communication and agent responses

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
MAGENTA='\033[0;35m'
NC='\033[0m' # No Color

# Configuration
BRIDGE_PORT="7890"
BRIDGE_LOG="$HOME/.paired/cascade_bridge/bridge.log"
AGENT_LOGS_DIR="$HOME/.paired/logs"

echo -e "${BLUE}üåä PAIRED Bridge Monitor${NC}"
echo "========================="
echo -e "${CYAN}Monitoring bridge at ws://localhost:$BRIDGE_PORT${NC}"
echo -e "${CYAN}Press Ctrl+C to stop${NC}"
echo ""

# Function to check bridge status
check_bridge_status() {
    if cd ~/.paired && node -e "
const WebSocket = require('ws');
const ws = new WebSocket('ws://localhost:$BRIDGE_PORT');
ws.on('open', () => { ws.close(); process.exit(0); });
ws.on('error', () => process.exit(1));
setTimeout(() => process.exit(1), 2000);
" 2>/dev/null; then
        echo -e "${GREEN}‚úÖ Bridge Service - Running (Port: $BRIDGE_PORT)${NC}"
        return 0
    else
        echo -e "${RED}‚ùå Bridge Service - Not accessible${NC}"
        return 1
    fi
}

# Function to show agent status via WebSocket
show_agent_status() {
    echo -e "${BLUE}üìä Agent Status:${NC}"
    local agents=("alex" "sherlock" "edison" "leonardo" "maya" "vince" "marie")
    
    # Get agent status via WebSocket health check
    local ws_response=$(cd ~/.paired && node -e "
const WebSocket = require('ws');
const ws = new WebSocket('ws://localhost:$BRIDGE_PORT');

ws.on('open', () => {
    ws.send(JSON.stringify({
        type: 'HEALTH_CHECK',
        instanceId: 'monitor-health-check',
        timestamp: Date.now()
    }));
});

ws.on('message', (data) => {
    try {
        const response = JSON.parse(data);
        if (response.type === 'health_response' || response.type === 'health_status' || response.teamAgentsActive !== undefined) {
            console.log(JSON.stringify(response));
        }
    } catch (e) {
        console.log('{}');
    }
    ws.close();
    process.exit(0);
});

ws.on('error', () => {
    console.log('{}');
    process.exit(1);
});

setTimeout(() => {
    console.log('{}');
    ws.close();
    process.exit(1);
}, 3000);
" 2>/dev/null || echo "{}")
    
    local team_active=$(echo "$ws_response" | grep -o '"agents":[0-9]*' | cut -d':' -f2 2>/dev/null || echo "0")
    
    if [ -n "$team_active" ] && [ "$team_active" -gt 0 ] 2>/dev/null; then
        echo -e "  ${GREEN}‚úÖ Bridge Service: Running (WebSocket Port $BRIDGE_PORT)${NC}"
        echo -e "  ${GREEN}‚úÖ Agents: $team_active/7 Active via Bridge${NC}"
    else
        echo -e "  ${RED}‚ùå Bridge Service: Not responding via WebSocket${NC}"
        echo -e "  ${RED}‚ùå Agents: 0/7 Active${NC}"
    fi
    
    echo ""
}

# Function to find bridge log file
find_bridge_log() {
    local possible_logs=(
        "$HOME/.paired/logs/bridge.log"
        "$HOME/.paired/bridge.log"
    )
    
    for log_file in "${possible_logs[@]}"; do
        if [ -f "$log_file" ]; then
            echo "$log_file"
            return 0
        fi
    done
    
    return 1
}

# Function to format log line with colors and emojis
format_log_line() {
    local line="$1"
    local timestamp=$(date '+%H:%M:%S')
    
    if [[ "$line" == *"ERROR"* ]]; then
        echo -e "${RED}[$timestamp] $line${NC}"
    elif [[ "$line" == *"WARN"* ]]; then
        echo -e "${YELLOW}[$timestamp] $line${NC}"
    elif [[ "$line" == *"INFO"* ]]; then
        echo -e "${CYAN}[$timestamp] $line${NC}"
    elif [[ "$line" == *"Alex"* ]]; then
        echo -e "${MAGENTA}[$timestamp] üëë $line${NC}"
    elif [[ "$line" == *"Sherlock"* ]]; then
        echo -e "${BLUE}[$timestamp] üïµÔ∏è $line${NC}"
    elif [[ "$line" == *"Edison"* ]]; then
        echo -e "${YELLOW}[$timestamp] ‚ö° $line${NC}"
    elif [[ "$line" == *"Leonardo"* ]]; then
        echo -e "${CYAN}[$timestamp] üèõÔ∏è $line${NC}"
    elif [[ "$line" == *"Maya"* ]]; then
        echo -e "${MAGENTA}[$timestamp] üé® $line${NC}"
    elif [[ "$line" == *"Vince"* ]]; then
        echo -e "${GREEN}[$timestamp] üèà $line${NC}"
    elif [[ "$line" == *"Marie"* ]]; then
        echo -e "${BLUE}[$timestamp] üî¨ $line${NC}"
    else
        echo "[$timestamp] $line"
    fi
}

# Function to monitor with periodic status updates
monitor_with_updates() {
    local log_file
    local timeout_duration=${MONITOR_TIMEOUT:-30}  # Default 30 seconds timeout
    
    log_file=$(find_bridge_log)
    
    if [ -z "$log_file" ]; then
        echo -e "${YELLOW}‚ö†Ô∏è  No bridge log file found${NC}"
        echo -e "${CYAN}üí° Checking common locations...${NC}"
        echo -e "${CYAN}   - $HOME/.paired/cascade_bridge/bridge.log${NC}"
        echo -e "${CYAN}   - $HOME/.paired/logs/bridge.log${NC}"
        echo -e "${CYAN}   - $HOME/.paired/bridge.log${NC}"
        echo ""
        echo -e "${YELLOW}üì° Monitoring bridge communication for ${timeout_duration}s...${NC}"
        
        # Monitor via API calls if no log file with timeout
        local count=0
        local max_iterations=$((timeout_duration / 10))
        
        while [ $count -lt $max_iterations ]; do
            clear
            echo -e "${BLUE}üåä PAIRED Bridge Monitor - Live Updates (${count}/${max_iterations})${NC}"
            echo "========================="
            echo -e "${CYAN}Monitoring bridge at ws://localhost:$BRIDGE_PORT${NC}"
            echo -e "${CYAN}Will exit in $((max_iterations - count)) iterations${NC}"
            echo ""
            
            check_bridge_status
            echo ""
            show_agent_status
            test_bridge_communication
            
            echo -e "${YELLOW}üì° Next update in 10 seconds...${NC}"
            sleep 10
            count=$((count + 1))
        done
        
        echo -e "${GREEN}‚úÖ Monitor completed after ${timeout_duration}s${NC}"
        return
    fi
    
    echo -e "${GREEN}‚úÖ Found bridge log: $log_file${NC}"
    echo ""
    
    # Show initial status
    echo -e "${YELLOW}üìã Bridge Log (last 10 lines):${NC}"
    tail -10 "$log_file" | while IFS= read -r line; do
        format_log_line "$line"
    done
    echo ""
    
    echo -e "${YELLOW}üì° Live Bridge Messages for ${timeout_duration}s:${NC}"
    echo -e "${CYAN}(Following bridge log in real-time...)${NC}"
    echo ""
    
    # Use timeout with tail to limit monitoring duration
    timeout ${timeout_duration}s tail -f "$log_file" | while IFS= read -r line; do
        format_log_line "$line"
    done
    
    echo ""
    echo -e "${GREEN}‚úÖ Monitor completed after ${timeout_duration}s${NC}"
}

# Function to monitor bridge log in real-time (legacy function for compatibility)
monitor_bridge_log() {
    monitor_with_updates
}

# Function to test bridge communication
test_bridge_communication() {
    echo -e "${YELLOW}üß™ Testing Bridge Communication:${NC}"
    
    # Test WebSocket connection and status
    local test_response=$(cd ~/.paired && node -e "
const WebSocket = require('ws');
const ws = new WebSocket('ws://localhost:$BRIDGE_PORT');

ws.on('open', () => {
    ws.send(JSON.stringify({
        type: 'STATUS_CHECK',
        instanceId: 'monitor-test',
        message: 'Bridge monitor test - please respond with status',
        projectPath: process.cwd()
    }));
});

ws.on('message', (data) => {
    try {
        const response = JSON.parse(data);
        console.log('WebSocket response received:', JSON.stringify(response).substring(0, 200));
        ws.close();
        process.exit(0);
    } catch (e) {
        console.log('Raw response:', data.toString().substring(0, 200));
        ws.close();
        process.exit(0);
    }
});

ws.on('error', (err) => {
    console.error('WebSocket error:', err.message);
    process.exit(1);
});

setTimeout(() => {
    console.log('WebSocket test timed out');
    ws.close();
    process.exit(1);
}, 5000);
" 2>/dev/null)
    
    if [ $? -eq 0 ] && [ -n "$test_response" ]; then
        echo -e "${GREEN}‚úÖ WebSocket communication test successful${NC}"
        echo -e "${CYAN}Response: $test_response${NC}"
    else
        echo -e "${YELLOW}‚ö†Ô∏è  WebSocket communication test failed or timed out${NC}"
    fi
    
    echo ""
}

# Main execution
case "${1:-monitor}" in
    "monitor" | "")
        check_bridge_status
        echo ""
        show_agent_status
        test_bridge_communication
        monitor_bridge_log
        ;;
    "status")
        check_bridge_status
        echo ""
        show_agent_status
        ;;
    "test")
        test_bridge_communication
        ;;
    "logs")
        if [ -f "$BRIDGE_LOG" ]; then
            echo -e "${YELLOW}üìã Bridge Log (last 50 lines):${NC}"
            tail -50 "$BRIDGE_LOG"
        else
            echo -e "${RED}‚ùå Bridge log not found at $BRIDGE_LOG${NC}"
        fi
        ;;
    "quick")
        # Quick 10-second monitor for testing
        MONITOR_TIMEOUT=10 monitor_bridge_log
        ;;
    "--help" | "-h")
        echo "PAIRED Bridge Monitor"
        echo ""
        echo "Usage:"
        echo "  $0 [monitor]   - Live monitoring with real-time log following (30s timeout)"
        echo "  $0 status      - Show current bridge and agent status"
        echo "  $0 test        - Test bridge communication"
        echo "  $0 logs        - Show recent bridge log entries"
        echo "  $0 quick       - Quick 10-second monitor for testing"
        echo "  $0 --help      - Show this help"
        echo ""
        echo "Environment Variables:"
        echo "  MONITOR_TIMEOUT - Set monitoring duration in seconds (default: 30)"
        echo ""
        echo "Features:"
        echo "  ‚Ä¢ Real-time bridge log monitoring with color coding"
        echo "  ‚Ä¢ Agent status checking with PID tracking"
        echo "  ‚Ä¢ Bridge health and communication testing"
        echo "  ‚Ä¢ Agent-specific message highlighting with emojis"
        echo "  ‚Ä¢ Automatic timeout to prevent infinite loops"
        ;;
    *)
        echo -e "${RED}‚ùå Unknown command: $1${NC}"
        echo "Use --help for usage information"
        exit 1
        ;;
esac
